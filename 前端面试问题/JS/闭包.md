闭包

了解闭包前先来了解一下上级作用域和堆栈内存释放问题。

上级作用域的概念
函数的上级作用域在哪里创建的，上级作用域就是谁。
var a = 10
function foo(){
    console.log(a)
}
function sum(){
    var a = 20
    foo()
}
sum() // 10
函数foo()是在全局下创建的，所以a的上级作用域就是window，输出就是10。

var n = 10
function fn(){
    var n =20
    function f() {
       n++;
       console.log(n)
     }
    f()
    return f
}

var x = fn()
x()
x()
console.log(n)
/* 输出
*  21
    22
    23
    10
/

思路：fn 的返回值是什么变量 x 就是什么，这里 fn 的返回值是函数名 f 也就是 f 的堆内存地址，x() 也就是执行的是函数 f()，而不是 fn()，
输出的结果显而易见

JS堆栈内存释放

堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。
堆内存释放：将引用类型的空间地址变量赋值成null，或没有变量占用堆内存了浏览器就会释放掉这个地址。
栈内存：提供代码执行的环境和存储基本类型值。
栈内存释放：一般当函数执行完后，函数的私有作用域就会被释放掉。

当栈内存的释放也有特殊情况：
1、函数执行完，但是函数的私有作用域内有内容被栈外的变量使用着，栈内存就不能释放，里面的基本值也就不会被释放掉。
2、全局下的栈内存只有页面被关闭的时候才会被释放。

闭包是什么？

在JS忍者秘籍中对闭包的定义：闭包允许函数访问并操作函数外部的变量。红宝书上对闭包的定义：闭包是指有权访问另一个函数作用域中的变量的函数。MDN对闭包的
定义为：闭包是指那些能够访问自由变量的函数。这里的自由变量是外部函数作用域中的变量。
概括上面的话就是，闭包是指有权访问另一个函数作用域中变量的函数。

形成闭包的原因

内部的函数存在外部作用域的引用就会形成闭包。从上面介绍的上级作用域的概念中其是就有闭包的例子return f就是一个表现形式。
var a = 0
function foo(){
    var b = 10
    function fn(){
        console.log(a, b)
    }
    fn()
}
foo()
这里的子函数fn内存就存在外部作用域的引用a，b，所以这就产生了闭包。

闭包的作用

a.保护函数的私有变量不受外部的干扰，形成不销毁的栈内存。
b.保存，把一些函数内的值保存下来，闭包可以实现方法和属性的私有化。

闭包经典使用场景

1、return回一个函数
var n = 10
function fn(){
    var n = 20
    function f(){
        n++;
        console.log(n)
    }
    return f
}
var x = fn()
x() // 21
这里的return f，f()就是一个闭包，存在上级作用域的引用。

2、函数作为参数
var a = '张三'
function foo(){
    var a = 'foo'
    function fn(){
        console.log(a)
    }
    return fn
}
function f(p){
    var a = 'f'
    p()
}
f(foo()) // foo
使用return fn返回回来，fn就是闭包，f(foo())执行的参数就是函数fn，因为fn中的a的上级作用域就是函数foo()，所以输出的就是foo。

3、IIFE（自执行函数）
var n = '李四'
(function p(){
    console.log(n)
})()
同时也是产生了闭包p()，存在window下的引用n。

4、循环赋值
for(var i = 0; i < 10; i++){
    (function (j){
        setTimeout(function (){
            console.log(j)
        }, 1000)
    })(i)
}
因为存在闭包的原因上面能依次输出1~10，闭包形成了10个互不干扰的私有作用域。将外层的自执行函数去掉后就不存在外部作用域的引用了，输出的结果就是连续的 10。
为什么会连续输出10，因为 JS 是单线程的，遇到异步的代码不会先执行(会入栈)，等到同步的代码执行完 i++ 到 10时，异步代码才开始执行此时的 i=10 输出的都是10。

5、使用回调函数就是在使用闭包
window.name = '王五'
setTimeout(function timer(){
    console.log(window.name)
}, 1000)


使用闭包需要注意什么？

容易导致内存泄漏。闭包会携带包含其他的函数作用域，因此会比其他函数占用更多的内存。过渡使用闭包会导致内存占用过多，所以要谨慎使用闭包。


经典面试题：

for循环和闭包
var data = []
for(var i = 0; i < 3; i++){
    data[i] = function(){
        console.log(i)
    }
}
data[0]()
data[1]()
data[2]()
// 3  3  3
这里的 i 是全局下的 i，共用一个作用域，当函数被执行的时候这时的 i=3，导致输出的结构都是3。

改善方法：
1、字执行函数和闭包
2、使用let
